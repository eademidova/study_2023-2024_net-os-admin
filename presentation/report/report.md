---
## Front matter
title: "Доклад на тему"
subtitle: "СУБД PostgreSQL"
author: "Демидова Екатерина Алексеевна"

## Generic otions
lang: ru-RU
toc-title: "Содержание"

## Bibliography
bibliography: bib/cite.bib
csl: pandoc/csl/gost-r-7-0-5-2008-numeric.csl

## Pdf output format
toc: true # Table of contents
toc-depth: 2
lof: true # List of figures
lot: true # List of tables
fontsize: 12pt
linestretch: 1.5
papersize: a4
documentclass: scrreprt
## I18n polyglossia
polyglossia-lang:
  name: russian
  options:
	- spelling=modern
	- babelshorthands=true
polyglossia-otherlangs:
  name: english
## I18n babel
babel-lang: russian
babel-otherlangs: english
## Fonts
mainfont: PT Serif
romanfont: PT Serif
sansfont: PT Sans
monofont: PT Mono
mainfontoptions: Ligatures=TeX
romanfontoptions: Ligatures=TeX
sansfontoptions: Ligatures=TeX,Scale=MatchLowercase
monofontoptions: Scale=MatchLowercase,Scale=0.9
## Biblatex
biblatex: true
biblio-style: "gost-numeric"
biblatexoptions:
  - parentracker=true
  - backend=biber
  - hyperref=auto
  - language=auto
  - autolang=other*
  - citestyle=gost-numeric
## Pandoc-crossref LaTeX customization
figureTitle: "Рис."
tableTitle: "Таблица"
listingTitle: "Листинг"
lofTitle: "Список иллюстраций"
lotTitle: "Список таблиц"
lolTitle: "Листинги"
## Misc options
indent: true
header-includes:
  - \usepackage{indentfirst}
  - \usepackage{float} # keep figures where there are in the text
  - \floatplacement{figure}{H} # keep figures where there are in the text
---

# Цель работы

Целью работы является изучение процесса установки и настройки, а также основных команд СУБД PostgreSQL.

# Задачи

-
-
-

# Теоретическое введение

Систе́ма управле́ния ба́зами да́нных, сокр. СУБД (англ. Database Management System, сокр. DBMS) — совокупность программных и лингвистических средств общего или специального назначения, обеспечивающих управление созданием и использованием баз данных (БД).

[ ГОСТ Р ИСО МЭК ТО 10032-2007: Эталонная модель управления данными (идентичен ISO/IEC TR 10032:2003 Information technology — Reference model of data management)]

СУБД — комплекс программ, позволяющих создать базу данных и манипулировать данными (вставлять, обновлять, удалять и выбирать). Система обеспечивает безопасность, надёжность хранения и целостность данных, а также предоставляет средства для администрирования БД. 

[Кузнецов С. Д. Основы баз данных. — 2-е изд. — М.: Интернет-университет информационных технологий; БИНОМ. Лаборатория знаний, 2007. — 484 с. — ISBN 978-5-94774-736-2.]

PostgreSQL — это объектно-реляционная система управления базами данных корпоративного класса с открытым исходным кодом, которая поддерживает запросы SQL (реляционные) и JSON (нереляционные). 

PostgreSQL основана на POSTGRES, Version 4.2 — программе, разработанной на факультете компьютерных наук Калифорнийского университета в Беркли. 

[https://postgrespro.ru/docs/postgresql/16/intro-whatis]

Она предлагает множество современных функций:

- сложные запросы
- внешние ключи
- триггеры
- изменяемые представления
- транзакционная целостность
- многоверсионность

Кроме того, пользователи могут всячески расширять возможности PostgreSQL, например создавая свои

- типы данных
- функции
- операторы
- агрегатные функции
- методы индексирования
- процедурные языки

В числе преимуществ также можно выделить:

- расширяемость (можно определять свои типы данных, создавать пользовательские функции);
- возможность индексирования географических объектов и присутствие расширения PostGIS;
- наследование концепция ООП, считающая, что абстрактный тип данных способен наследовать данные и набор функций уже существующего типа, способствуя переиспользованию компонентов ПО;
- масштабируемая система встроенных языков программирования;
- устойчивые и надежные функции репликаций и транзакций.

У PostgreSQL большой список поддерживаемых данных: численные типы, символьные типы, двоичные типы, «дата/время», булев тип, геометрические примитивы и т.д.


Соглашения #

Следующие соглашения используются в описаниях команд: квадратные скобки ([ и ]) обозначают необязательные части. Фигурные скобки ({ и }) и вертикальная черта (|) обозначают выбор одного из предложенных вариантов. Многоточие (...) означает, что предыдущий элемент можно повторить.

Иногда для ясности команды SQL предваряются приглашением =>, а команды оболочки — приглашением $.

Под администратором здесь обычно понимается человек, ответственный за установку и запуск сервера, тогда как пользователь — кто угодно, кто использует или желает использовать любой компонент системы PostgreSQL.

# Установка PostgreSQL и работа с базами данных

Установите пакет Postgres вместе с пакетом -contrib, который добавляет некоторые дополнительные утилиты и функции:

```
sudo apt install postgresql postgresql-contrib
```

Мы можем проверить состояние службы PostgreSQL, чтобы убедиться, что установка прошла гладко. Введите команду ниже в терминал(рис. @fig:001):

```
sudo systemctl status postgresql
```

![Проверка состояния службы PostgreSQL](image/1.png){#fig:001 width=70%}

Как и любую другую серверную службу, доступную для внешнего мира, PostgreSQL рекомендуется запускать под именем отдельного пользователя. Эта учётная запись должна владеть только данными, которыми управляет сервер, и разделять её с другими службами не следует. В частности, рекомендуется не назначать этого пользователя владельцем исполняемых файлов PostgreSQL, чтобы их нельзя было подменить в случае компрометации серверного процесса.

PostgreSQL по умолчанию использует систему аутентификации на основе ролей. Будучи суперпользователем, пользователь postgres имеет полные административные права. Введите следующую команду, чтобы войти в систему как пользователь postgres:

```
sudo su - postgres
```

Затем, чтобы получить доступ к командной строке PostgreSQL, введите:

```
psql
```

Теперь вы попадете в командную строку PostgreSQL, где сможете вводить команды SQL(рис. @fig:002).

![Командная строка PostgreSQL](2.png){#fig:002 width=70%}

Для создания пользователя в Unix-подобной системе следует искать команду useradd или adduser.

С помощью команды createuser в PostgreSQL вы можете создавать новые роли непосредственно из командной строки. «Myuser» будет названием нашей новой роли. Сначала нажмите Enter после ввода «q», чтобы завершить приглашение PostgreSQL. затем введите команду следующим образом:

```
createuser --interactive --pwprompt
```

Система предложит вам ввести пароль и имя новой роли (мы будем использовать «myuser»). Затем вам будет предложено выбрать, должна ли новая роль быть суперпользователем. Безопаснее ответить «нет» по соображениям безопасности, если только вам специально не требуются права суперпользователя для этой роли(рис. @fig:003).

![Создание нового пользователя](3.png){#fig:003 width=70%}

Просмотреть список пользователей можно с помощью psql-команды `\du`(рис. @fig:004).

![Список пользователей](4.png){#fig:004 width=70%}

С помощью команды «createdb» вы можете создавать новые базы данных точно так же, как вы можете создавать новые роли из командной строки. Начнем с создания новой базы данных под названием «mydb». Используйте следующую команду:

```
createdb mydb
```

Просмотреть список баз данных можно с помощью psql-команды `\l`(рис. @fig:005).

![Список баз данных](5.png){#fig:005 width=70%}

Удалить эту базу данных можно с помощью команды:

```
drop mydb
```

Чтобы получить доступ к новой базе данных с новой ролью, сначала выйдите из пользовательской оболочки postgres, набрав «exit» и нажав Enter. Затем введите следующую команду:

```
psql -d mydb -U myuser
```

Вам будет предложено ввести пароль для «myuser». После ввода пароля вы увидите приглашение PostgreSQL для базы данных mydb.

Также создать базу данных можно с помощью команд SQL. Создадим базу данных books_store с помщью команды `CREATE DATABASE books_store;`. Перейти в неё можно с помощью psql команды `\c books_store`(рис. @fig:006). После перехода в базу данных создадим в ней две таблицы с помощью выражения `CREATE TABLE`. Таблица author с двумя столбцами:

- `id` -- уникальный целочисленный идентификатор автора, выполняющий роль первичного ключа таблицы (и не поддерживающий NULL-значения по умолчанию);

- `name` -- текстовое поле, не поддерживающее NULL-значения. В нем будут храниться фамилии и инициалы авторов книг.

Таблица book с четырьмя столбцами:

- `id` -- уникальный целочисленный идентификатор книги, выполняющий роль первичного ключа таблицы (и не поддерживающий NULL-значения по умолчанию);

- `title` -- текстовое поле, не поддерживающее NULL-значения. В нем будут храниться названия книг;

- `author_id` -- целочисленное поле, не поддерживающее NULL-значения. В нем будут храниться уникальные идентификаторы авторов книг. Для явного определения связи между таблицами author и book (и соблюдения целостности их данных) будет добавлен внешний ключ fk_author, основанный на столбце author_id;

- `public_year` -- целочисленное поле, поддерживающее NULL-значения. В нем будут храниться годы публикации книг.


![Создание базы данных и таблиц в ней](6.png){#fig:006 width=70%}

Чтобы проверить существование таблицы и получить информацию о ней, можно использовать команды `\d <table_name>` и `\dt`(рис. @fig:007). Первая команда возвращает краткую информацию о столбцах таблицы с именем `<table_name>`: название, тип, collation, допустимость NULL-значений и значение по умолчанию. Также команда выводит индексы и первичные/внешние ключи таблицы. Команда `\dt` возвращает список всех отношений (relations), хранимых в текущей базе данных. По каждому объекту БД выводится следующая информация: имя схемы, название, тип и владелец.

![Получение информации о таблицах](7.png){#fig:007 width=70%}


# Определение параметров в файле конфигурации

Самый основной способ установки этих параметров — определение их значений в файле postgresql.conf, который обычно находится в каталоге данных. При инициализации каталога кластера БД в этот каталог помещается копия стандартного файла. Например, он может выглядеть так: 

```
# Это комментарий
log_connections = yes
log_destination = 'syslog'
search_path = '"$user", public'
shared_buffers = 128MB
```

Каждый параметр определяется в отдельной строке. Знак равенства в ней между именем и значением является необязательным. Пробельные символы в строке не играют роли (кроме значений, заключённых в апострофы), а пустые строки игнорируются. Знаки решётки (#) обозначают продолжение строки как комментарий. Значения параметров, не являющиеся простыми идентификаторами или числами, должны заключаться в апострофы. 


Основной процесс сервера перечитывает файл конфигурации заново, получая сигнал SIGHUP; послать его проще всего можно, запустив pg_ctl reload в командной строке или вызвав SQL-функцию pg_reload_conf(). Основной процесс сервера передаёт этот сигнал всем остальным запущенным серверным процессам, так что существующие сеансы тоже получают новые значения (после того, как завершится выполнение текущей команды клиента). Также возможно послать этот сигнал напрямую одному из серверных процессов. Учтите, что некоторые параметры можно установить только при запуске сервера; любые изменения их значений в файле конфигурации не будут учитываться до перезапуска сервера. Более того, при обработке SIGHUP игнорируются неверные значения параметров (но об этом сообщается в журнале).

В дополнение к postgresql.conf в каталоге данных Postgres Pro содержится файл postgresql.auto.conf, который имеет тот же формат, что и postgresql.conf, но предназначен для автоматического изменения, а не для редактирования вручную. Этот файл содержит параметры, задаваемые командой ALTER SYSTEM. Он считывается одновременно с postgresql.conf и заданные в нём параметры действуют таким же образом. Параметры в postgresql.auto.conf переопределяют те, что указаны в postgresql.conf.

В Postgres Pro есть три SQL-команды, задающие для параметров значения по умолчанию. Уже упомянутая команда ALTER SYSTEM даёт возможность изменять глобальные значения средствами SQL; она функционально равнозначна редактированию postgresql.conf. Кроме того, есть ещё две команды, которые позволяют задавать значения по умолчанию на уровне баз данных и ролей:

    Команда ALTER DATABASE позволяет переопределить глобальные параметры на уровне базы данных.

    Команда ALTER ROLE позволяет переопределить для конкретного пользователя как глобальные, так и локальные для базы данных параметры.

Значения, установленные командами ALTER DATABASE и ALTER ROLE, применяются только при новом подключении к базе данных. 

Когда клиент подключён к базе данных, он может воспользоваться двумя дополнительными командами SQL (и равнозначными функциями), которые предоставляет Postgres Pro для управления параметрами конфигурации:

    Команда SHOW позволяет узнать текущее значение всех параметров. Соответствующая ей функция — current_setting(имя_параметра text).

    Команда SET позволяет изменить текущее значение параметров, которые действуют локально в рамках сеанса; на другие сеансы она не влияет. Соответствующая ей функция — set_config(имя_параметра, новое_значение, локально).

Кроме того, просмотреть и изменить значения параметров для текущего сеанса можно в системном представлении pg_settings:

    Запрос на чтение представления выдаёт ту же информацию, что и SHOW ALL, но более подробно. Этот подход и более гибкий, так как в нём можно указать условия фильтра или связать результат с другими отношениями.

    Выполнение UPDATE для этого представления, а именно присвоение значения столбцу, равносильно выполнению команды SET. Например, команде

    SET configuration_parameter TO DEFAULT;

    равнозначен запрос:

    UPDATE pg_settings SET setting = reset_val WHERE name = 'configuration_parameter';


Управление параметрами в командной строке

Помимо изменения глобальных значений по умолчанию и переопределения их на уровне базы данных или роли, параметры Postgres Pro можно изменить, используя средства командной строки. Управление через командную строку поддерживают и сервер, и клиентская библиотека libpq.

    При запуске сервера, значения параметров можно передать команде postgres в аргументе командной строки -c. Например:

    postgres -c log_connections=yes -c log_destination='syslog'

    Параметры, заданные таким образом, переопределяют те, что были установлены в postgresql.conf или командой ALTER SYSTEM, так что их нельзя изменить глобально без перезапуска сервера.

При запуске клиентского сеанса, использующего libpq, значения параметров можно указать в переменной окружения PGOPTIONS. Заданные таким образом параметры будут определять значения по умолчанию на время сеанса, но никак не влияют на другие сеансы. По историческим причинам формат PGOPTIONS похож на тот, что применяется при запуске команды postgres; в частности, в нём должен присутствовать флаг -c. Например:

env PGOPTIONS="-c geqo=off -c statement_timeout=5min" psql

Другие клиенты и библиотеки могут иметь собственные механизмы управления параметрами, через командную строку или как-то иначе, используя которые пользователь сможет менять параметры сеанса, не выполняя непосредственно команды SQL.

Расположения файлов

В дополнение к вышеупомянутому postgresql.conf, Postgres Pro обрабатывает два редактируемых вручную файла конфигурации, в которых настраивается аутентификация клиентов (их использование рассматривается в Главе 19). По умолчанию все три файла конфигурации размещаются в каталоге данных кластера БД. Параметры, описанные в этом разделе, позволяют разместить их и в любом другом месте. (Это позволяет упростить администрирование, в частности, выполнять резервное копирование этих файлов обычно проще, когда они хранятся отдельно.)

data_directory (string)

    Задаёт каталог, в котором хранятся данные. Этот параметр можно задать только при запуске сервера.
config_file (string)

    Задаёт основной файл конфигурации сервера (его стандартное имя — postgresql.conf). Этот параметр можно задать только в командной строке postgres.
hba_file (string)

    Задаёт файл конфигурации для аутентификации по сетевым узлам (его стандартное имя — pg_hba.conf). Этот параметр можно задать только при старте сервера.
ident_file (string)

    Задаёт файл конфигурации для сопоставлений имён пользователей (его стандартное имя — pg_ident.conf). Этот параметр можно задать только при запуске сервера. См. также Раздел 19.2.
external_pid_file (string)

    Задаёт имя дополнительного файла с идентификатором процесса (PID), который будет создавать сервер для использования программами администрирования. Этот параметр можно задать только при запуске сервера.

 Параметры подключений

listen_addresses (string)

    Задаёт адреса TCP/IP, по которым сервер будет принимать подключения клиентских приложений. Это значение принимает форму списка, разделённого запятыми, из имён и/или числовых IP-адресов компьютеров. Особый элемент, *, обозначает все имеющиеся IP-интерфейсы. Запись 0.0.0.0 позволяет задействовать все адреса IPv4, а :: — все адреса IPv6. Если список пуст, сервер не будет привязываться ни к какому IP-интерфейсу, а значит, подключиться к нему можно будет только через Unix-сокеты. По умолчанию этот параметр содержит localhost, что допускает подключение к серверу по TCP/IP только через локальный интерфейс «замыкания». Хотя механизм аутентификации клиентов (см. Главу 19) позволяет гибко управлять доступом пользователей к серверу, параметр listen_addresses может ограничить интерфейсы, через которые будут приниматься соединения, что бывает полезно для предотвращения злонамеренных попыток подключения через незащищённые сетевые интерфейсы. Этот параметр можно задать только при запуске сервера.
port (integer)

    TCP-порт, открываемый сервером; по умолчанию, 5432. Заметьте, что этот порт используется для всех IP-адресов, через которые сервер принимает подключения. Этот параметр можно задать только при запуске сервера.
max_connections (integer)

    Определяет максимальное число одновременных подключений к серверу БД. По умолчанию обычно это 100 подключений, но это число может быть меньше, если ядро накладывает свои ограничения (это определяется в процессе initdb). Этот параметр можно задать только при запуске сервера.

    Для ведомого сервера значение этого параметра должно быть больше или равно значению на ведущем. В противном случае на ведомом сервере не будут разрешены запросы.
superuser_reserved_connections (integer)

    Определяет количество «слотов» подключений, которые Postgres Pro будет резервировать для суперпользователей. При этом всего одновременно активными могут быть максимум max_connections подключений. Когда число активных одновременных подключений больше или равно max_connections минус superuser_reserved_connections, принимаются только подключения суперпользователей, а все другие подключения, в том числе подключения для репликации, запрещаются.

    По умолчанию резервируются три соединения. Это значение должно быть меньше значения max_connections. Задать этот параметр можно только при запуске сервера.
unix_socket_directories (string)

    Задаёт каталог Unix-сокета, через который сервер будет принимать подключения клиентских приложений. Создать несколько сокетов можно, перечислив в этом значении несколько каталогов через запятую. Пробелы между элементами этого списка игнорируются; если в пути каталога содержатся пробелы, его нужно заключать в двойные кавычки. При пустом значении сервер не будет работать с Unix-сокетами, в этом случае к нему можно будет подключиться только по TCP/IP. Значение по умолчанию обычно /tmp, но его можно изменить во время сборки. Задать этот параметр можно только при запуске сервера.

    Помимо самого файла сокета, который называется .s.PGSQL.nnnn (где nnnn — номер порта сервера), в каждом каталоге unix_socket_directories создаётся обычный файл .s.PGSQL.nnnn.lock. Ни в коем случае не удаляйте эти файлы вручную.

    Этот параметр не действует в системе Windows, так как в ней нет Unix-сокетов.
unix_socket_group (string)

    Задаёт группу-владельца Unix-сокетов. (Пользователем-владельцем сокетов всегда будет пользователь, запускающий сервер.) В сочетании с unix_socket_permissions данный параметр можно использовать как дополнительный механизм управления доступом к Unix-сокетам. По умолчанию он содержит пустую строку, то есть группой-владельцем становится основная группа пользователя, запускающего сервер. Задать этот параметр можно только при запуске сервера.

    Этот параметр не действует в системе Windows, так как в ней нет Unix-сокетов.
unix_socket_permissions (integer)

    Задаёт права доступа к Unix-сокетам. Для Unix-сокетов применяется обычный набор разрешений Unix. Значение параметра ожидается в числовом виде, который принимают функции chmod и umask. (Для применения обычного восьмеричного формата число должно начинаться с 0 (нуля).)

    По умолчанию действуют разрешения 0777, при которых подключаться к сокету могут все. Другие разумные варианты — 0770 (доступ имеет только пользователь и группа, см. также unix_socket_group) и 0700 (только пользователь). (Заметьте, что для Unix-сокетов требуется только право на запись, так что добавлять или отзывать права на чтение/выполнение не имеет смысла.)

    Этот механизм управления доступом не зависит от описанного в Главе 19.

    Этот параметр можно задать только при запуске сервера.

    Данный параметр неприменим для некоторых систем, в частности, Solaris (а именно Solaris 10), которые полностью игнорируют разрешения для сокетов. В таких системах примерно тот же эффект можно получить, указав в параметре unix_socket_directories каталог, доступ к которому ограничен должным образом. Этот параметр также неприменим в Windows, где нет Unix-сокетов.
bonjour (boolean)

    Включает объявления о существовании сервера посредством Bonjour. По умолчанию выключен. Задать этот параметр можно только при запуске сервера.
bonjour_name (string)

    Задаёт имя службы в среде Bonjour. Если значение этого параметра — пустая строка ('') (это значение по умолчанию), в качестве этого имени используется имя компьютера. Этот параметр игнорируется, если сервер был скомпилирован без поддержки Bonjour. Задать этот параметр можно только при запуске сервера.
tcp_keepalives_idle (integer)

    Задаёт период неактивности (в секундах), после которого по TCP клиенту должен отправляться сигнал сохранения соединения. При значении 0 действует системный параметр. Этот параметр поддерживается только в системах, воспринимающих параметр сокета TCP_KEEPIDLE или равнозначный, а также в Windows; в других системах он должен быть равен нулю. В сеансах, подключённых через Unix-сокеты, он игнорируется и всегда считается равным 0.
tcp_keepalives_interval (integer)

    Задаёт интервал (в секундах), по истечении которого следует повторять сигнал сохранения соединения, если ответ от клиента не был получен. При значении 0 действует системная величина. Этот параметр поддерживается только в системах, воспринимающих параметр сокета TCP_KEEPINTVL или равнозначный, а также в Windows; в других системах он должен быть равен нулю. В сеансах, подключённых через Unix-сокеты, он игнорируется и всегда считается равным 0.
tcp_keepalives_count (integer)

    Задаёт число TCP-сигналов сохранения соединения, которые могут быть потеряны до того, как соединение сервера с клиентом будет признано прерванным. При значении 0 действует системная величина. Этот параметр поддерживается только в системах, воспринимающих параметр сокета TCP_KEEPCNT или равнозначный; в других системах он должен быть равен нулю. В сеансах, подключённых через Unix-сокеты, он игнорируется и всегда считается равным 0.




 Безопасность и аутентификация

authentication_timeout (integer)

    Максимальное время, за которое должна произойти аутентификация (в секундах). Если потенциальный клиент не сможет пройти проверку подлинности за это время, сервер закроет соединение. Благодаря этому зависшие при подключении клиенты не будут занимать соединения неограниченно долго. Значение этого параметра по умолчанию — одна минута (1m). Задать этот параметр можно только в postgresql.conf или в командной строке при запуске сервера.
ssl (boolean)

    Разрешает SSL-подключения. Прежде чем включать SSL, прочитайте Раздел 17.9. По умолчанию он выключен (off). Этот параметр можно задать только при запуске сервера. SSL-подключения поддерживаются только для соединений по TCP/IP.
ssl_ca_file (string)

    Задаёт имя файла, содержащего сертификаты центров сертификации (ЦС) для SSL-сервера. По умолчанию этот параметр пуст; то есть информация о ЦС не загружается и проверка клиентских сертификатов не выполняется. (В предыдущих выпусках Postgres Pro это имя было фиксированным: root.crt.) При указании относительного пути он рассматривается от каталога данных. Задать этот параметр можно только при запуске сервера.
ssl_cert_file (string)

    Задаёт имя файла, содержащего сертификат SSL-сервера. Имя по умолчанию — server.crt. Относительные пути рассматриваются от каталога данных. Задать этот параметр можно только при запуске сервера.
ssl_crl_file (string)

    Задаёт имя файла, содержащего список отзыва сертификатов (CRL) для SSL-сервера. По умолчанию не определён, то есть файл CRL не загружается. (В предыдущих выпусках Postgres Pro это имя было фиксированным: root.crl.) При указании относительного пути он рассматривается от каталога данных. Задать этот параметр можно только при запуске сервера.
ssl_key_file (string)

    Задаёт имя файла, содержащего закрытый ключ SSL-сервера. По умолчанию имеет значение server.key. При указании относительного пути он рассматривается от каталога данных. Задать этот параметр можно только при запуске сервера.
ssl_ciphers (string)

    Задаёт список наборов шифров SSL, которые могут применяться для защиты соединений. Синтаксис этого параметра и список поддерживаемых значений можно найти на странице ciphers руководства по OpenSSL. По умолчанию этот параметр имеет значение HIGH:MEDIUM:+3DES:!aNULL. Обычно оно вполне приемлемо при отсутствии особых требований по безопасности. Этот параметр можно задать только при запуске сервера.

    Объяснение значения по умолчанию:

    HIGH

        Наборы шифров, в которых используются шифры из группы высокого уровня (HIGH), (например: AES, Camellia, 3DES)
    MEDIUM

        Наборы шифров, в которых используются шифры из группы среднего уровня (MEDIUM) (например, RC4, SEED)
    +3DES

        Порядок шифров для группы HIGH по умолчанию в OpenSSL определён некорректно. В нём 3DES оказывается выше AES128, что неправильно, так как он считается менее безопасным, чем AES128, и работает гораздо медленнее. Включение +3DES меняет этот порядок, чтобы данный алгоритм следовал после всех шифров групп HIGH и MEDIUM.
    !aNULL

        Отключает наборы анонимных шифров, не требующие проверки подлинности. Такие наборы уязвимы для атак с посредником, поэтому использовать их не следует.

    Конкретные наборы шифров и их свойства очень различаются от версии к версии OpenSSL. Чтобы получить фактическую информацию о них для текущей установленной версии OpenSSL, выполните команду openssl ciphers -v 'HIGH:MEDIUM:+3DES:!aNULL'. Учтите, что этот список фильтруется во время выполнения, в зависимости от типа ключа сервера.
ssl_prefer_server_ciphers (bool)

    Определяет, должны ли шифры SSL сервера предпочитаться клиентским. По умолчанию предпочтение отдаётся шифрам сервера. Этот параметр можно задать только при запуске сервера.

    В старых версиях Postgres Pro этот параметр отсутствовал и предпочтение отдавалось выбору клиента. Введён этот параметр в основном для обеспечения совместимости с этими версиями. Вообще же обычно лучше использовать конфигурацию сервера, так как в конфигурации на стороне клиента более вероятны ошибки.
ssl_ecdh_curve (string)

    Задаёт имя кривой для использования при обмене ключами ECDH. Эту кривую должны поддерживать все подключающиеся клиенты. Это не обязательно должна быть кривая, с которой был получен ключ сервера. По умолчанию выбирается кривая prime256v1. Этот параметр можно задать только при запуске сервера.

    Наиболее популярные кривые OpenSSL: prime256v1 (NIST P-256), secp384r1 (NIST P-384) и secp521r1 (NIST P-521).

    Полный список доступных кривых можно получить командой openssl ecparam -list_curves. Однако не все из них пригодны для TLS.
password_encryption (boolean)

    Этот параметр определяет, будет ли пароль шифроваться, когда он передаётся в CREATE USER или ALTER ROLE без указания ENCRYPTED или UNENCRYPTED. По умолчанию этот параметр установлен (on), то есть пароль шифруется.
krb_server_keyfile (string)

    Задаёт размещение файла ключей для сервера Kerberos. За подробностями обратитесь к Подразделу 19.3.3. Задать этот параметр можно только в postgresql.conf или в командной строке при запуске сервера.
krb_caseins_users (boolean)

    Определяет, должны ли имена пользователей GSSAPI обрабатываться без учёта регистра. По умолчанию значение этого параметра — off (регистр учитывается). Задать этот параметр можно только в postgresql.conf или в командной строке при запуске сервера.
db_user_namespace (boolean)

    Этот параметр позволяет относить имена пользователей к базам данных. По умолчанию он имеет значение off (выключен). Задать этот параметр можно только в postgresql.conf или в командной строке при запуске сервера.

    Если он включён, имена создаваемых пользователей должны иметь вид пользователь@база_данных. Когда подключающийся клиент передаёт имя пользователь, к этому имени добавляется @ с именем базы данных, и сервер идентифицирует пользователя по этому полному имени. Заметьте, что для создания пользователя с именем, содержащим @, в среде SQL потребуется заключить это имя в кавычки.

    Когда этот параметр включён, он не мешает создавать и использовать обычных глобальных пользователей. Чтобы подключиться с таким именем пользователя, достаточно добавить к имени @, например так: joe@. Получив такое имя, сервер отбросит @, и будет идентифицировать пользователя по начальному имени.

    Параметр db_user_namespace порождает расхождение между именами пользователей на стороне сервера и клиента. Но проверки подлинности всегда выполняются с именем с точки зрения сервера, так что, настраивая аутентификацию, следует указывать серверное представление имени, а не клиентское. Так как метод аутентификации md5 подмешивает имя пользователя в качестве соли и на стороне сервера, и на стороне клиента, при включённом параметре db_user_namespace использовать md5 невозможно.


# Выполнение лабораторной работы

Описываются проведённые действия, в качестве иллюстрации даётся ссылка на иллюстрацию (рис. @fig:001).

![Название рисунка](image/placeimg_800_600_tech.jpg){#fig:001 width=70%}

# Выводы

Здесь кратко описываются итоги проделанной работы.

# Список литературы{.unnumbered}

::: {#refs}
:::
